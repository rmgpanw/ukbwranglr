# NOTES -------------------------------------------------------------------

#TODO
# - Add col of dates being coverted to NA in data_dict - perhaps these
#should NOT be converted to NA (presence of a date indicates an event probably
#happened, even if the date is unknown)
#
#

# EXPORTED FUNCTIONS ----------------------------------------------------

#' Generate a data dictionary from a raw UK Biobank phenotype file
#'
#' @param ukb_pheno Either the path to a UKB phenotype file or the file already
#'   loaded into R as a data frame.
#' @param delim Delimiter for the UKB phenotype file. Default is "\\t". Ignored
#'   if the file name ends with \code{.dta} (i.e. is a \code{STATA} file).
#' @param ukb_data_dict The UKB data dictionary. This should be a data frame
#'   where all columns are of type \code{character}. By default, this is
#'   downloaded from the
#'   \href{https://github.com/rmgpanw/ukbwranglr_resources}{\code{ukbwranglr_resources}}
#'    github repo.
#'
#' @return A data dictionary (data table) specific to the specified UKB
#'   phenotype. This includes a column of descriptive names. TODO: flesh this
#'   out
#' @export
make_data_dict <- function(ukb_pheno,
                            delim = "\t",
                            ukb_data_dict = get_ukb_data_dict()) {

  # extract column names - ukb_pheno can be a file path or a dataframe already
  # loaded into R
  if (class(ukb_pheno)[1] == "character") {
    # read column names only
    # stata file
    if (stringr::str_detect(ukb_pheno, "\\.dta$")) {
      message("`ukb_pheno` appears to be a STATA file. Ignoring `delim` argument")
      colheaders_raw <-
        haven::read_dta(file = ukb_pheno, n_max = 0) %>%
        names()
    } else {
      # flat file
      colheaders_raw <- data.table::fread(
        ukb_pheno,
        colClasses = c('character'),
        na.strings = c("", "NA"),
        sep = delim,
        header = TRUE,
        data.table = TRUE,
        showProgress = TRUE,
        nrows = 0
        ) %>%
          names()
    }

  } else if (all(class(ukb_pheno) %in% c("data.table", "data.frame", "tbl_df", "tbl"))) {
       colheaders_raw <- names(ukb_pheno)
  } else {
    stop("Error! `ukb_pheno` must be either a string specifying the filepath for a UKB main dataset, or a UKb dataset loaded into R as a data frame")
  }

  # process header to this form: 'f.5912.0.0'
  colheaders <- format_ukb_df_header(colheaders_raw)

  # make mapping df
  # convert column names to a tibble and append 'mapping' columns
  mapping_df <- dplyr::tibble(
    colheaders_raw = colheaders_raw,
    colheaders_processed = colheaders
    ) %>%
    # Make columns for FieldID, instance and array
    tidyr::separate(col = "colheaders_processed",
                    sep = "\\.",
                    into = c("temp", "FieldID", "instance", "array"),
                    remove= FALSE,
                    fill = "right" # 'eid' column will not separate so will raise an error without this option
                    ) %>%

    # Remove column of "f"'s
    dplyr::select(-.data[["temp"]]) %>%

    # join with full ukb data dictionary
    dplyr::left_join(y = ukb_data_dict,
                     by = "FieldID")


  # mutate 'descriptive_colnames' column
  mapping_df <- mutate_descriptive_columns(data_dict = mapping_df)

  # mutate 'cont_int_to_na' column: indicates whether all special codings for a
  # continuous/integer variable can be cleaned to 'NA' (see also
  # `ukb_select_codings_to_na.Rmd`)
  mapping_df$cont_int_to_na <- dplyr::case_when(
      # CONVERT TO NA
    mapping_df$Coding %in% ukbwranglr:::cont_and_int_codings_to_na ~ TRUE,

      # DO *NOT* CONVERT TO NA
    mapping_df$Coding %in% ukbwranglr:::cont_and_int_codings_NOT_to_na ~ FALSE,
      TRUE ~ FALSE
    )

  ## return mapping_df
  return(mapping_df)
}



#' Read a UK Biobank phenotype file
#'
#' Reads a UK Biobank phenotype file into R and relabels coded values with their
#' descriptive meanings. Depends on a data dictionary generated by
#' \code{\link{make_data_dict}}. To load only a selection of columns, supply a
#' filtered version of this data dictionary containing only the desired fields.
#'
#' @param path The path to a UKB phenotype file.
#' @param delim Delimiter for the UKB phenotype file. Default is \code{\\t}
#' @param data_dict A data dictionary specific to the UKB phenotype file,
#'   generated by \code{\link{make_data_dict}}.
#' @param ukb_codings The UKB codings dictionary. This should be a data frame
#'   where all columns are of type \code{character}. By default, this is
#'   downloaded from the
#'   \href{https://github.com/rmgpanw/ukbwranglr_resources}{\code{ukbwranglr_resources}}
#'   github repo.
#' @param clean_dates If \code{TRUE}, "nonsense" dates are converted to
#'   \code{NA}. TODO add detail
#' @param clean_selected_continuous_and_integers If \code{TRUE}, certain special
#'   continuous/integer codings are converted to \code{NA}. TODO add detail
#' @param ... Additional parameters are passed on to
#'   \code{\link[data.table]{fread}} when reading in UKB phenotype file
#' @inheritParams make_data_dict
#' @inheritParams data.table::fread
#'
#' @return A UK Biobank phenotype dataset as a data table with human-readable
#'   variables labels and data values.
#' @export
read_pheno <- function(path,
                       delim = "\t",
                       data_dict,
                       ukb_data_dict = get_ukb_data_dict(),
                       ukb_codings = get_ukb_codings(),
                       clean_dates = FALSE,
                       clean_selected_continuous_and_integers = FALSE,
                       na.strings = c("", "NA"),
                       ...
                       ) {

  start_time <- proc.time()

# Helper functions ---------------------------------------------------------------

  # extracts codings from a filtered ukb_data_dict nested by ValueType
  extract_codings_for_valuetype <-
    function(.ukb_data_dict_filt_nested,
             .valuetype) {
      # try statement avoids failure if the dataset does not contain a ValueType
      # (e.g. if there are no "Categorical multiple" ValueTypes)
      try(
        .ukb_data_dict_filt_nested[(.ukb_data_dict_filt_nested$ValueType == .valuetype), ]$data[[1]]$Coding,
        silent = TRUE
        )
    }

  # extracts Values/Meanings for a specified Coding from a filtered ukb_codings
  # nested by 'Coding'
  extract_value_meaning_for_coding <-
    function(.ukb_codings_filt_nested,
             .coding,
             .value_meaning) {
      # options: 'Value', 'Meaning')
      .ukb_codings_filt_nested[(.ukb_codings_filt_nested$Coding == .coding), ][[2]][[1]][[.value_meaning]]
    }

# Setup --------------------------------------------------------------------

#SETUP
  # read selected columns from raw phenotype file
  message("Reading selected columns for raw phenotype data")
  if (stringr::str_detect(path, "\\.dta$")) {
    # stata file
    message("`path` appears to be a STATA file. Ignoring `delim` argument")
    ukb_df <-
      haven::read_dta(file = path,
                      col_select = tidyselect::all_of(data_dict$colheaders_raw))
  } else {
    # flat file
    ukb_df <- data.table::fread(
      path,
      select = data_dict$colheaders_raw,
      # selected cols
      colClasses = c('character'),
      na.strings = na.strings,
      sep = delim,
      ...
    )
  }

  # filter ukb data dictionary file for fields in dataset and nest by ValueType
  ukb_data_dict_filt_nested <- ukb_data_dict %>%
    dplyr::filter(.data[["FieldID"]] %in% data_dict$FieldID) %>%
    dplyr::group_by(.data[["ValueType"]]) %>%
    tidyr::nest()

  # filter ukb codings file for codings in dataset and nest by Coding
  ukb_codings_filt_nested <- ukb_codings %>%
    dplyr::filter(.data[["Coding"]] %in% unique(data_dict$Coding)) %>%
    dplyr::group_by(.data[["Coding"]]) %>%
    tidyr::nest()

  # IMPORTANT: now reorder ukb_codings_filt_nested by Value ...otherwise, Fields
  # like month of birth (ID = 52) will be correctly labelled BUT incorrectly
  # levelled Notes on this: - Some codings (e.g. [Month of
  # Birth](http://biobank.ctsu.ox.ac.uk/crystal/coding.cgi?id=8)) should be
  # ordered, whereas others are not (e.g. coding 3,
  # ['Cancer'](http://biobank.ctsu.ox.ac.uk/crystal/coding.cgi?id=3)) - Values
  # for Codings are read as 'character' type and therefore coercing to integer
  # returns some NA's. - Selecting levels/labels in the order provided by
  # `Codings.tsv` returns the wrong levels for these variables - I therefore
  # reorder these by integer value where possible (some cannot be converted to
  # integer, in which case it's ok, they just do not get/need to be reordered),
  # before assigning levels

  ukb_codings_filt_nested$data <- purrr::map(
    .x = ukb_codings_filt_nested$data,
    .f = ~ suppressWarnings(.x %>%
                              dplyr::arrange(as.integer(.data[["Value"]])))
  )

# LOOP BY CODING ----------------------------------------------------------
# Categorical variables: convert to labelled factors
# Dates: remove nonsense dates (if clean_dates == TRUE)
#

  message('Processing categorical variables +/- cleaning dates/continuous variables...')

  # Set up progress bar
  pb <- progress::progress_bar$new(format = "[:bar] :current/:total (:percent)",
                                   total = length(unique(stats::na.omit(data_dict$Coding))))
  pb$tick(0)

  # loop through codings and parse columns depending on associated ValueType
  for (coding in unique(stats::na.omit(data_dict$Coding))) {

    # progress bar
    pb$tick(1)

    # Relabel categorical variables --------------------------------------------------------------------
    if ((
      coding %in% extract_codings_for_valuetype(
        .ukb_data_dict_filt_nested = ukb_data_dict_filt_nested,
        .valuetype = 'Categorical multiple'
      )
    ) |
    (
      coding %in% extract_codings_for_valuetype(
        .ukb_data_dict_filt_nested = ukb_data_dict_filt_nested,
        .valuetype = 'Categorical single'
      )
    )) {
      ### define levels and labels
      .levels <-
        extract_value_meaning_for_coding(
          .ukb_codings_filt_nested = ukb_codings_filt_nested,
          .coding = coding,
          .value_meaning = "Value"
        )

      .labels <-
        extract_value_meaning_for_coding(
          .ukb_codings_filt_nested = ukb_codings_filt_nested,
          .coding = coding,
          .value_meaning = "Meaning"
        )

      ### identify Fields that use this coding
      selected_cols <- data_dict %>%
        dplyr::filter(.data[["Coding"]] == coding) %>%
        .$colheaders_raw

      ### now convert selected columns to labelled factors
      ukb_df <- ukb_df %>%
        dplyr::mutate(dplyr::across(tidyselect::all_of(selected_cols),
                                    function(.x) {
                                      ordered(.x, levels = .levels, labels = .labels)
                                    }))

# Clean dates (if requested) ------------------------------------
    } else if (
      ((coding %in% extract_codings_for_valuetype(.ukb_data_dict_filt_nested = ukb_data_dict_filt_nested,
                                    .valuetype = 'Date')) &
       (clean_dates == TRUE))
    ) {

      ### identify Fields that use this coding
      selected_cols <- data_dict %>%
        dplyr::filter(.data[["Coding"]] == coding) %>%
        .$colheaders_raw

      #### vector of 'nonsense dates'
      nonsense_dates <- c(
        '1904-04-04',
        '1900-01-01',
        '1910-01-01',
        '1920-01-01',
        '1930-01-01',
        '1901-01-01',
        '1902-02-02',
        '1903-03-03',
        '2037-07-07'
      )

      #### temp function to remove 'nonsense' dates
      special_values_to_na <- function(.x) {
        replace(.x, .x %in% nonsense_dates, NA)
      }

      #### remove 'nonsense' dates
      ukb_df <- ukb_df %>%
        dplyr::mutate(dplyr::across(tidyselect::all_of(selected_cols),
                             special_values_to_na))

# Clean selected continuous values (if requested) -------------
      ## continuous - note, only a few continuous FieldIDs have an associated coding, one of which
      ## should not be automatically set to NA
      ## Only execute this if clean_selected_continuous_and_integers = TRUE

      } else if (
      (clean_selected_continuous_and_integers == TRUE) &
      # (coding %in% extract_codings_for_valuetype(
      #   .ukb_data_dict_filt_nested = ukb_data_dict_filt_nested,
      #   .valuetype = 'Continuous')
      # ) &
      (data_dict %>%
       dplyr::filter(.data[["ValueType"]] == 'Continuous' & .data[["Coding"]] == coding) %>%
       dplyr::slice(1L) %>%
       .$cont_int_to_na %>% # 'isTRUE' will return 'FALSE' if this statement returns 'logical(0)' i.e. no rows returned, whereas '== TRUE' throws an error
       isTRUE)) {

      ### extract special coding values
      .values <-
        extract_value_meaning_for_coding(
          .ukb_codings_filt_nested = ukb_codings_filt_nested,
          .coding = coding,
          .value_meaning = "Value"
        )

      ### temp function to replace these special values
      special_values_to_na <- function(.x) {
        replace(.x, .x %in% .values, NA)
      }

      ### identify Fields that use this coding
      selected_cols <- data_dict %>%
        dplyr::filter(.data[["Coding"]] == coding) %>%
        .$colheaders_raw

      ### replace special coding values with 'NA' for selected columns
      ukb_df <- ukb_df %>%
        dplyr::mutate(dplyr::across(tidyselect::all_of(selected_cols),
                                    special_values_to_na))

# Clean selected integer values (if requested) -------------
      ## see ukb_mapping_generator() and ukb_select_codings_to_na.Rmd for details re which
      ## Codings I think can be automatically set to NA
      ## Only execute this if clean_selected_continuous_and_integers = TRUE
    } else if (
      (clean_selected_continuous_and_integers == TRUE) &
      # (coding %in% extract_codings_for_valuetype(
      #   .ukb_data_dict_filt_nested = ukb_data_dict_filt_nested,
      #   .valuetype = 'Integer')
      # ) &
      (data_dict %>%
       dplyr::filter(.data[["ValueType"]] == 'Integer' & .data[["Coding"]] == coding) %>%
       dplyr::slice(1L) %>%
       .$cont_int_to_na %>% # 'isTRUE' will return 'FALSE' if this statement returns 'logical(0)' i.e. no rows returned, whereas '== TRUE' throws an error
       isTRUE)) {

      ### extract special coding values
      .values <-
        extract_value_meaning_for_coding(
          .ukb_codings_filt_nested = ukb_codings_filt_nested,
          .coding = coding,
          .value_meaning = "Value"
        )

      ### create anonymous function to replace these special values
      special_values_to_na <- function(.x) {
        replace(.x, .x %in% .values, NA)
      }

      ### identify Fields that use this coding
      selected_cols <- data_dict %>%
        dplyr::filter(.data[["Coding"]] == coding) %>%
        .$colheaders_raw

      ### replace special coding values with 'NA' for selected columns
      ukb_df <- ukb_df %>%
        dplyr::mutate(dplyr::across(tidyselect::all_of(selected_cols),
                                    special_values_to_na))
    }
  }

# CHANGE COLUMN TYPES -----------------------------------------------------
# Dates -------------------------------------------------------------------
  message('Converting dates...')
  # extract column names
  selected_cols <- data_dict %>%
    dplyr::filter(.data[["ValueType"]] == 'Date') %>%
    .$colheaders_raw

  ### convert selected columns to date
  ukb_df <- ukb_df %>%
    dplyr::mutate(dplyr::across(tidyselect::all_of(selected_cols),
                                lubridate::as_date))


# Continuous --------------------------------------------------------------
  message('Converting continuous variables...')
  # extract column names
  selected_cols <- data_dict %>%
    dplyr::filter(.data[["ValueType"]] == 'Continuous') %>%
    .$colheaders_raw

  ### convert selected columns to numeric
  ukb_df <- ukb_df %>%
    dplyr::mutate(dplyr::across(tidyselect::all_of(selected_cols),
                                as.numeric))


# Integer -----------------------------------------------------------------

  message('Converting integer variables...')
  # extract column names
  selected_cols <- data_dict %>%
    dplyr::filter(.data[["ValueType"]] == 'Integer') %>%
    .$colheaders_raw

  ### convert selected columns to integer
  ukb_df <- ukb_df %>%
    dplyr::mutate(dplyr::across(tidyselect::all_of(selected_cols),
                                as.integer))

# Rename columns ----------------------------------------------------------
  message('Renaming columns...')
  names(ukb_df) <- data_dict$descriptive_colnames


# Completion messages ------------------------------------------------------
  time_taken <- proc.time() - start_time

  message(
    "Complete! Time taken: ",
    (time_taken[3] %/% 60),
    " minutes, ",
    (round(time_taken[3] %% 60)),
    " seconds"
  )

  # Message re 'uncleaned' cols if in 'cleaning mode' i.e. number of continuous/integer columns with special values NOT set to 'NA'
  if (clean_selected_continuous_and_integers == TRUE) {
    message(
      '\n\nNumber of continuous/integer fields in this dataset that still have "uncleaned" special values: ',
      data_dict %>%
        dplyr::filter(
          .data[["ValueType"]] %in% c('Continuous', 'Integer') &
            !is.na(.data[["Coding"]]) &
            .data[["cont_int_to_na"]] == FALSE
        ) %>%
        nrow()
    )
  }

  # Return output -----------------------------------------------------------
  return(ukb_df)
}

# PRIVATE FUNCTIONS -------------------------------------------------------

#' Mutates a column of descriptive colnames
#'
#' @param data_dict A data dictionary formed by joining the column names
#'   from a raw ukb pheno file with the ukb data dictionary
#'   (https://biobank.ctsu.ox.ac.uk/~bbdatan/Data_Dictionary_Showcase.tsv)
#'
#' Helper function for \code{data_dict()}
#'
#' @noRd
mutate_descriptive_columns <- function(data_dict) {

  # Create vector of column names and Field_FieldID names from Field
  # descriptions/instance/array indices
  column_names <- paste(data_dict$Field,
                        paste0("f", data_dict$FieldID),
                        data_dict$instance,
                        data_dict$array)

  Field_FieldID_names <- paste(data_dict$Field,
                               data_dict$FieldID)

  # Replace the first with 'eid'
  column_names[1] <- 'eid'
  Field_FieldID_names[1] <- 'eid'

  # replace special characters and convert to lower case
  column_names <- remove_special_characters_and_make_lower_case(column_names)
  Field_FieldID_names <- remove_special_characters_and_make_lower_case(Field_FieldID_names)

  # # Replace special characters
  # ## characters to be replaced with "_"
  # to_underscore <- c(" - ",
  #                    " ",
  #                    "/",
  #                    "\\.")
  #
  # for (string in to_underscore) {
  #   column_names <- stringr::str_replace_all(column_names, string, "_")
  #   Field_FieldID_names <- stringr::str_replace_all(Field_FieldID_names, string, "_")
  # }
  #
  # ## characters to replace with "" (i.e. to remove)
  # to_remove <- c("\\(",
  #                "\\)",
  #                "\\-",
  #                ",",
  #                ":")
  #
  # for (string in to_remove) {
  #   column_names <- stringr::str_replace_all(column_names, string, "")
  #   Field_FieldID_names <- stringr::str_replace_all(Field_FieldID_names, string, "")
  # }
  #
  # # make lowercase
  # column_names <- tolower(column_names)
  # Field_FieldID_names <- tolower(Field_FieldID_names)

  # mutate column with new, 'descriptive' column names and Field_FieldID_names
  data_dict[['descriptive_colnames']] <- column_names
  data_dict[['Field_FieldID']] <- Field_FieldID_names

  # Rearrange columns
  data_dict <- data_dict %>%
    dplyr::select(
      .data[["descriptive_colnames"]],
      .data[["Field_FieldID"]],
      tidyselect::everything()
    )

  return(data_dict)
}



#' Processes a ukb pheno file header to match the form 'f.5912.0.0'
#'
#' @param colheaders A character vector. The first item should contain 'eid'
#'   i.e. the first column should be the eid column.
#'
#' @return A ukb pheno file header (character vector) of the form 'f.5912.0.0'.
#'   Returns the header unaltered if already in this form
#'
#'   Helper function for \code{data_dict()}
#'
#' @noRd
format_ukb_df_header <- function(colheaders) {

  # Process colheaders not of the form 'f.5912.0.0'
  assertthat::assert_that(stringr::str_detect(colheaders[1],
                                              "eid"),
                          msg = "Error! First column name should include 'eid'")

  colheaders[1] <- "f.eid"

    # desired colname format (ukb.tab, as part of R download)
    # str_detect(string = c("f.eid", "f.5912.0.0"),
    #           pattern = "[:alpha:]\\.[:digit:]+\\.[:digit:]+\\.[:digit:]+")

    # ukb.txt format
    ukb_txt_format_indices <- stringr::str_which(string = colheaders,
               pattern = "[:digit:]+-[:digit:]+\\.[:digit:]+")

    colheaders[ukb_txt_format_indices] <- paste0("f.", gsub("-", ".", colheaders[ukb_txt_format_indices]))

    # ukb.dta format
    ukb_dta_format_indices <- stringr::str_which(string = colheaders,
               pattern = "[:alpha:]_[:digit:]+_[:digit:]+_[:digit:]+")

    colheaders[ukb_dta_format_indices] <- paste0("f.", gsub("_", ".", stringr::str_replace(colheaders[ukb_dta_format_indices],
                                                                              pattern = "^[:alpha:]+_",
                                                                              replacement = "")))

    # TODO: add tests for colheaders:
    # - all valid headers? (i.e. are all present in ukb data dictionary)
    # - any repeated?
    # - mixed colheader formats?
    return(colheaders)
  }



#' Convert descriptive colnames to dataframe of FieldID/instance/array
#' combinations
#'
#' @param x a character vector of descriptive colnames generated by
#'   \code{\link{data_dict}}
#'
#' @return a dataframe of extracted FieldID/instance/array values and all their
#'   possible combinations
#' @noRd
colname_to_field_inst_array_df <- function(x) {

  # extract fieldid_instance_array (removing "f")
  x <- stringr::str_extract(x, pattern = "_f[:digit:]+_[:digit:]+_[:digit:]+$") %>%
    stringr::str_sub(3L, -1L)

  # make into single column tibble
  x <- tibble::tibble(fieldid_instance_array = x)

  # separate into field_id, instance and array. Also mutate cols with all
  # possible combinations
  x <- x %>%
    tidyr::separate(col = "fieldid_instance_array",
             into = c("fieldid", "instance", "array"),
             sep = "_",
             remove = FALSE)
  x$fieldid_instance <- paste(x$fieldid, x$instance, sep = "_")
  x$instance_array <- paste(x$instance, x$array, sep = "_")

  return(x)
}
