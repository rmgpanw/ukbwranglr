# NOTES -------------------------------------------------------------------

#TODO
# - Add col of dates being coverted to NA in data_dict - perhaps these
#should NOT be converted to NA (presence of a date indicates an event probably
#happened, even if the date is unknown)
#
#

# EXPORTED FUNCTIONS ----------------------------------------------------


# TEST --------------------------------------------------------------------


# read_pheno2 <- function() {
#
# }
#
# ukb_data_dict <- get_ukb_data_dict()
# ukb_codings <- get_ukb_codings()
# table(ukb_data_dict$ValueType)
#
# ukb_dummy <- download_dummy_ukb_data_to_tempdir()
#
# ukb_dummy_raw <- data.table::fread(ukb_dummy)
# ukb_dummy_data_dict <- make_data_dict(ukb_dummy_raw)

# categorical needs reading as type character (e.g. icd10 codes)

# 1. make valuetype:R class list/dictionaryread as

# TEST END ----------------------------------------------------------------



#' Read a UK Biobank phenotype file
#'
#' Reads a UK Biobank phenotype file into R and relabels coded values with their
#' descriptive meanings. Depends on a data dictionary generated by
#' \code{\link{make_data_dict}}. To load only a selection of columns, supply a
#' filtered version of this data dictionary containing only the desired fields.
#'
#' @param path The path to a UKB phenotype file.
#' @param delim Delimiter for the UKB phenotype file. Default is \code{\\t}
#' @param data_dict A data dictionary specific to the UKB phenotype file,
#'   generated by \code{\link{make_data_dict}}.
#' @param ukb_codings The UKB codings dictionary. This should be a data frame
#'   where all columns are of type \code{character}. By default, this is
#'   downloaded from the
#'   \href{https://github.com/rmgpanw/ukbwranglr_resources}{\code{ukbwranglr_resources}}
#'   github repo.
#' @param clean_dates If \code{TRUE}, "nonsense" dates are converted to
#'   \code{NA}. TODO add detail
#' @param clean_selected_continuous_and_integers If \code{TRUE}, certain special
#'   continuous/integer codings are converted to \code{NA}. TODO add detail
#' @param ... Additional parameters are passed on to
#'   \code{\link[data.table]{fread}} when reading in UKB phenotype file
#' @inheritParams make_data_dict
#' @inheritParams data.table::fread
#'
#' @return A UK Biobank phenotype dataset as a data table with human-readable
#'   variables labels and data values.
#' @export
read_pheno <- function(path,
                       delim = "\t",
                       data_dict,
                       ukb_data_dict = get_ukb_data_dict(),
                       ukb_codings = get_ukb_codings(),
                       clean_dates = FALSE,
                       clean_selected_continuous_and_integers = FALSE,
                       na.strings = c("", "NA"),
                       ...
                       ) {

  start_time <- proc.time()

# Helper functions ---------------------------------------------------------------

  # extracts codings from a filtered ukb_data_dict nested by ValueType
  extract_codings_for_valuetype <-
    function(.ukb_data_dict_filt_nested,
             .valuetype) {
      # try statement avoids failure if the dataset does not contain a ValueType
      # (e.g. if there are no "Categorical multiple" ValueTypes)
      try(
        .ukb_data_dict_filt_nested[(.ukb_data_dict_filt_nested$ValueType == .valuetype), ]$data[[1]]$Coding,
        silent = TRUE
        )
    }

  # extracts Values/Meanings for a specified Coding from a filtered ukb_codings
  # nested by 'Coding'
  extract_value_meaning_for_coding <-
    function(.ukb_codings_filt_nested,
             .coding,
             .value_meaning) {
      # options: 'Value', 'Meaning')
      .ukb_codings_filt_nested[(.ukb_codings_filt_nested$Coding == .coding), ][[2]][[1]][[.value_meaning]]
    }

# Setup --------------------------------------------------------------------

#SETUP
  # read selected columns from raw phenotype file
  message("Reading selected columns for raw phenotype data")
  if (stringr::str_detect(path, "\\.dta$")) {
    # stata file
    message("`path` appears to be a STATA file. Ignoring `delim` argument")
    ukb_df <-
      haven::read_dta(file = path,
                      col_select = tidyselect::all_of(data_dict$colheaders_raw))
  } else {
    # flat file
    ukb_df <- data.table::fread(
      path,
      select = data_dict$colheaders_raw,
      # selected cols
      colClasses = c('character'),
      na.strings = na.strings,
      sep = delim,
      ...
    )
  }

  # filter ukb data dictionary file for fields in dataset and nest by ValueType
  ukb_data_dict_filt_nested <- ukb_data_dict %>%
    dplyr::filter(.data[["FieldID"]] %in% data_dict$FieldID) %>%
    dplyr::group_by(.data[["ValueType"]]) %>%
    tidyr::nest()

  # filter ukb codings file for codings in dataset and nest by Coding
  ukb_codings_filt_nested <- ukb_codings %>%
    dplyr::filter(.data[["Coding"]] %in% unique(data_dict$Coding)) %>%
    dplyr::group_by(.data[["Coding"]]) %>%
    tidyr::nest()

  # IMPORTANT: now reorder ukb_codings_filt_nested by Value ...otherwise, Fields
  # like month of birth (ID = 52) will be correctly labelled BUT incorrectly
  # levelled Notes on this: - Some codings (e.g. [Month of
  # Birth](http://biobank.ctsu.ox.ac.uk/crystal/coding.cgi?id=8)) should be
  # ordered, whereas others are not (e.g. coding 3,
  # ['Cancer'](http://biobank.ctsu.ox.ac.uk/crystal/coding.cgi?id=3)) - Values
  # for Codings are read as 'character' type and therefore coercing to integer
  # returns some NA's. - Selecting levels/labels in the order provided by
  # `Codings.tsv` returns the wrong levels for these variables - I therefore
  # reorder these by integer value where possible (some cannot be converted to
  # integer, in which case it's ok, they just do not get/need to be reordered),
  # before assigning levels

  ukb_codings_filt_nested$data <- purrr::map(
    .x = ukb_codings_filt_nested$data,
    .f = ~ suppressWarnings(.x %>%
                              dplyr::arrange(as.integer(.data[["Value"]])))
  )

# LOOP BY CODING ----------------------------------------------------------
# Categorical variables: convert to labelled factors
# Dates: remove nonsense dates (if clean_dates == TRUE)
#

  message('Processing categorical variables +/- cleaning dates/continuous variables...')

  # Set up progress bar
  pb <- progress::progress_bar$new(format = "[:bar] :current/:total (:percent)",
                                   total = length(unique(stats::na.omit(data_dict$Coding))))
  pb$tick(0)

  # loop through codings and parse columns depending on associated ValueType
  for (coding in unique(stats::na.omit(data_dict$Coding))) {

    # progress bar
    pb$tick(1)

    # Relabel categorical variables --------------------------------------------------------------------
    if ((
      coding %in% extract_codings_for_valuetype(
        .ukb_data_dict_filt_nested = ukb_data_dict_filt_nested,
        .valuetype = 'Categorical multiple'
      )
    ) |
    (
      coding %in% extract_codings_for_valuetype(
        .ukb_data_dict_filt_nested = ukb_data_dict_filt_nested,
        .valuetype = 'Categorical single'
      )
    )) {
      ### define levels and labels
      .levels <-
        extract_value_meaning_for_coding(
          .ukb_codings_filt_nested = ukb_codings_filt_nested,
          .coding = coding,
          .value_meaning = "Value"
        )

      .labels <-
        extract_value_meaning_for_coding(
          .ukb_codings_filt_nested = ukb_codings_filt_nested,
          .coding = coding,
          .value_meaning = "Meaning"
        )

      ### identify Fields that use this coding
      selected_cols <- data_dict %>%
        dplyr::filter(.data[["Coding"]] == coding) %>%
        .$colheaders_raw

      ### now convert selected columns to labelled factors
      ukb_df <- ukb_df %>%
        dplyr::mutate(dplyr::across(tidyselect::all_of(selected_cols),
                                    function(.x) {
                                      ordered(.x, levels = .levels, labels = .labels)
                                    }))

# Clean dates (if requested) ------------------------------------
    } else if (
      ((coding %in% extract_codings_for_valuetype(.ukb_data_dict_filt_nested = ukb_data_dict_filt_nested,
                                    .valuetype = 'Date')) &
       (clean_dates == TRUE))
    ) {

      ### identify Fields that use this coding
      selected_cols <- data_dict %>%
        dplyr::filter(.data[["Coding"]] == coding) %>%
        .$colheaders_raw

      #### vector of 'nonsense dates'
      nonsense_dates <- c(
        '1904-04-04',
        '1900-01-01',
        '1910-01-01',
        '1920-01-01',
        '1930-01-01',
        '1901-01-01',
        '1902-02-02',
        '1903-03-03',
        '2037-07-07'
      )

      #### temp function to remove 'nonsense' dates
      special_values_to_na <- function(.x) {
        replace(.x, .x %in% nonsense_dates, NA)
      }

      #### remove 'nonsense' dates
      ukb_df <- ukb_df %>%
        dplyr::mutate(dplyr::across(tidyselect::all_of(selected_cols),
                             special_values_to_na))

# Clean selected continuous values (if requested) -------------
      ## continuous - note, only a few continuous FieldIDs have an associated coding, one of which
      ## should not be automatically set to NA
      ## Only execute this if clean_selected_continuous_and_integers = TRUE

      } else if (
      (clean_selected_continuous_and_integers == TRUE) &
      # (coding %in% extract_codings_for_valuetype(
      #   .ukb_data_dict_filt_nested = ukb_data_dict_filt_nested,
      #   .valuetype = 'Continuous')
      # ) &
      (data_dict %>%
       dplyr::filter(.data[["ValueType"]] == 'Continuous' & .data[["Coding"]] == coding) %>%
       dplyr::slice(1L) %>%
       .$cont_int_to_na %>% # 'isTRUE' will return 'FALSE' if this statement returns 'logical(0)' i.e. no rows returned, whereas '== TRUE' throws an error
       isTRUE)) {

      ### extract special coding values
      .values <-
        extract_value_meaning_for_coding(
          .ukb_codings_filt_nested = ukb_codings_filt_nested,
          .coding = coding,
          .value_meaning = "Value"
        )

      ### temp function to replace these special values
      special_values_to_na <- function(.x) {
        replace(.x, .x %in% .values, NA)
      }

      ### identify Fields that use this coding
      selected_cols <- data_dict %>%
        dplyr::filter(.data[["Coding"]] == coding) %>%
        .$colheaders_raw

      ### replace special coding values with 'NA' for selected columns
      ukb_df <- ukb_df %>%
        dplyr::mutate(dplyr::across(tidyselect::all_of(selected_cols),
                                    special_values_to_na))

# Clean selected integer values (if requested) -------------
      ## see ukb_mapping_generator() and ukb_select_codings_to_na.Rmd for details re which
      ## Codings I think can be automatically set to NA
      ## Only execute this if clean_selected_continuous_and_integers = TRUE
    } else if (
      (clean_selected_continuous_and_integers == TRUE) &
      # (coding %in% extract_codings_for_valuetype(
      #   .ukb_data_dict_filt_nested = ukb_data_dict_filt_nested,
      #   .valuetype = 'Integer')
      # ) &
      (data_dict %>%
       dplyr::filter(.data[["ValueType"]] == 'Integer' & .data[["Coding"]] == coding) %>%
       dplyr::slice(1L) %>%
       .$cont_int_to_na %>% # 'isTRUE' will return 'FALSE' if this statement returns 'logical(0)' i.e. no rows returned, whereas '== TRUE' throws an error
       isTRUE)) {

      ### extract special coding values
      .values <-
        extract_value_meaning_for_coding(
          .ukb_codings_filt_nested = ukb_codings_filt_nested,
          .coding = coding,
          .value_meaning = "Value"
        )

      ### create anonymous function to replace these special values
      special_values_to_na <- function(.x) {
        replace(.x, .x %in% .values, NA)
      }

      ### identify Fields that use this coding
      selected_cols <- data_dict %>%
        dplyr::filter(.data[["Coding"]] == coding) %>%
        .$colheaders_raw

      ### replace special coding values with 'NA' for selected columns
      ukb_df <- ukb_df %>%
        dplyr::mutate(dplyr::across(tidyselect::all_of(selected_cols),
                                    special_values_to_na))
    }
  }

# CHANGE COLUMN TYPES -----------------------------------------------------
# Dates -------------------------------------------------------------------
  message('Converting dates...')
  # extract column names
  selected_cols <- data_dict %>%
    dplyr::filter(.data[["ValueType"]] == 'Date') %>%
    .$colheaders_raw

  ### convert selected columns to date
  ukb_df <- ukb_df %>%
    dplyr::mutate(dplyr::across(tidyselect::all_of(selected_cols),
                                lubridate::as_date))


# Continuous --------------------------------------------------------------
  message('Converting continuous variables...')
  # extract column names
  selected_cols <- data_dict %>%
    dplyr::filter(.data[["ValueType"]] == 'Continuous') %>%
    .$colheaders_raw

  ### convert selected columns to numeric
  ukb_df <- ukb_df %>%
    dplyr::mutate(dplyr::across(tidyselect::all_of(selected_cols),
                                as.numeric))


# Integer -----------------------------------------------------------------

  message('Converting integer variables...')
  # extract column names
  selected_cols <- data_dict %>%
    dplyr::filter(.data[["ValueType"]] == 'Integer') %>%
    .$colheaders_raw

  ### convert selected columns to integer
  ukb_df <- ukb_df %>%
    dplyr::mutate(dplyr::across(tidyselect::all_of(selected_cols),
                                as.integer))

# Rename columns ----------------------------------------------------------
  message('Renaming columns...')
  names(ukb_df) <- data_dict$descriptive_colnames


# Completion messages ------------------------------------------------------
  time_taken <- proc.time() - start_time

  message(
    "Complete! Time taken: ",
    (time_taken[3] %/% 60),
    " minutes, ",
    (round(time_taken[3] %% 60)),
    " seconds"
  )

  # Message re 'uncleaned' cols if in 'cleaning mode' i.e. number of continuous/integer columns with special values NOT set to 'NA'
  if (clean_selected_continuous_and_integers == TRUE) {
    message(
      '\n\nNumber of continuous/integer fields in this dataset that still have "uncleaned" special values: ',
      data_dict %>%
        dplyr::filter(
          .data[["ValueType"]] %in% c('Continuous', 'Integer') &
            !is.na(.data[["Coding"]]) &
            .data[["cont_int_to_na"]] == FALSE
        ) %>%
        nrow()
    )
  }

  # Return output -----------------------------------------------------------
  return(ukb_df)
}

# PRIVATE FUNCTIONS -------------------------------------------------------

#' Convert descriptive colnames to dataframe of FieldID/instance/array
#' combinations
#'
#' @param x a character vector of descriptive colnames generated by
#'   \code{\link{data_dict}}
#'
#' @return a dataframe of extracted FieldID/instance/array values and all their
#'   possible combinations
#' @noRd
colname_to_field_inst_array_df <- function(x) {
  # make x into a df
  x <- data.frame(descriptive_colnames = x)

  # extract fieldid_instance_array (removing "_f")
  x$fieldid_instance_array <-
    stringr::str_extract(x$descriptive_colnames,
                         pattern = "_f[:digit:]+_[:digit:]+_[:digit:]+$") %>%
    stringr::str_sub(3L,-1L)

  # make description column (descriptive colname minus fieldid_instance_array)
  x$description <- stringr::str_replace(x$descriptive_colnames,
                               paste0("_f", x$fieldid_instance_array),
                               "")

  # separate into field_id, instance and array. Also mutate cols with all
  # possible combinations
  x <- x %>%
    tidyr::separate(col = "fieldid_instance_array",
             into = c("fieldid", "instance", "array"),
             sep = "_",
             remove = FALSE)
  x$fieldid_instance <- paste(x$fieldid, x$instance, sep = "_")
  x$instance_array <- paste(x$instance, x$array, sep = "_")

  return(x)
}
