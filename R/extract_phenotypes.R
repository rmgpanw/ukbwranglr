# NOTES -------------------------------------------------------------------

# Section 'Get all diagnostic codes' - functions to generate long format dataframes
# with standardised formats, listing all diagnostic codes for each eid. Separate
# functions created for each data source (i.e. self-report, HES, primary care
# etc)

# Section 'Get specific diagnostic codes, first recorded' - for a set of
# specific diagnostic codes, extract a list of eid's with these codes and the
# earliest recorded date. Depends on output from the 'get all diagnostic codes'
# functions

#TODO

# optimise field_id_pivot_longer_multi() - set an 'index' column and filter this for
#non-na values before performing inner_join() e.g. for self-reported non-cancer
#diagnoses, fieldid 20002 would be the index col: if there is no self-reported
#diagnosis, then the associated date and age at diagnosis columns will also be
#empty.

# For 'get all diagnostic codes' functions, each starts with the required
# fieldids. Recode the remainder of the functions to use this so any changes
# only need to be made at the start (maybe separate into 'code_fid' and 'date_fid' variables?)

# EXPORTED FUNCTIONS ----------------------------------------------------

# Get specific diagnostic codes, first recorded -------------------------------------------------------

#' Get the earliest record date for a set of diagnostic codes
#'
#' For a set of diagnostic codes, extract individuals with at least one of these
#' and retrieve the earliest recorded date (if available).
#'
#' @section Under the hood:
#'
#'   Filters a long format dataframe of diagnostic codes generated by one of the
#'   'get all diagnostic codes' functions (e.g.
#'   \code{\link{get_hes_icd10_diagnoses}}), filters this for the specified
#'   `codes` then groups by individual (eid). For each individual, the earliest
#'   date is then retrieved. If no dates are available, the first diagnostic
#'   code as it appears in the data is retrieved instead.
#'
#' @inheritParams get_first_diagnostic_code_record_basis
#'
#' @return Dataframe
#' @export
#' @family get specific diagnostic codes, first recorded
get_first_diagnostic_code_record <- function(df,
                                             codes) {

  # extract earliest date
  df <- get_first_diagnostic_code_record_basis(df = df,
                                         code = codes)

  # drop nested column
  df %>%
    dplyr::select(-data) %>%
    dplyr::ungroup()
}

# Get all diagnostic codes -------------------------------------------------------

#' Convert column for a FieldID to long format
#'
#' Helper function. Selects the columns relating to a specified FieldID (plus the 'eid' column)
#' and applies \code{\link[tidyr]{pivot_longer}}.
#'
#' @param field_id Character. A UK Biobank Field ID
#' @inheritParams read_pheno
#' @inheritParams summarise_rowise
#'
#' @return A dataframe with 3 columns: \itemize{ \item eid \item column names
#'   (labelled as the specified `field_id`, prefixed by 'f') \item column values
#'   (labelled as he specified `field_id`, prefixed by 'f' and suffixed by
#'   '_value') }
#'
#' @export
#'
#' @family extract disease outcomes helpers
field_id_pivot_longer <- function(ukb_pheno,
                                  field_id,
                                  data_dict,
                                  ukb_codings) {

  # check a single field_id has been supplied
  assertthat::is.string(field_id)

  # filter ukb_pheno for selected cols (eid + fieldid cols)
  required_cols <- get_colnames_for_fieldids(field_id = field_id,
                                             data_dict = data_dict)

  check_required_cols_exist(df = ukb_pheno,
                            required_cols)

  ukb_pheno <- ukb_pheno %>%
    dplyr::select(eid,
                  tidyselect::all_of(required_cols))

  # get codings for fieldid
  field_id_codings <- ukb_codings %>%
    dplyr::filter(Coding == (data_dict %>%
                               dplyr::filter(FieldID == field_id) %>%
                               .$Coding %>%
                               head(n = 1)))

  ukb_pheno <- ukb_pheno %>%
    tidyr::pivot_longer(
      cols = tidyselect::all_of(required_cols),
      values_to = paste(paste0("f", field_id), "value", sep = "_")
    ) %>%
    dplyr::mutate(instance_array = colname_to_field_inst_array_df(name)$instance_array)

  # rename
  names(ukb_pheno)[which(names(ukb_pheno) == 'name')] <- paste0("f", field_id)

  return(ukb_pheno)
}


#' Apply pivot_longer across multiple sets of columns
#'
#' Helper function.
#'
#' This should only be applied to related FieldIDs which are each associated
#' with the same number of columns. For example, FieldIDs 20002, 20008, and
#' 20009 all pertain to self-reported non-cancer illnesses.
#'
#' Raises and error if the supplied FieldIDs are associated with differing
#' numbers of columns, or if the result has more rows than expected.
#'
#' @section Under the hood:
#'
#'   Maps \code{\link{field_id_pivot_longer}} to a set of FieldIDs, then
#'   recombines the results into a single dataframe using
#'   \code{\link[dplyr]{inner_join}}.
#'
#' @param field_ids Character vector of FieldIDs
#' @inheritParams field_id_pivot_longer
#'
#' @return Dataframe.
#' @export
#'
#' @family extract disease outcomes helpers
field_id_pivot_longer_multi <- function(field_ids,
                                        ukb_pheno,
                                        data_dict,
                                        ukb_codings) {

  required_cols <- get_colnames_for_fieldids(field_ids = field_ids,
                                             data_dict = data_dict)

  check_required_cols_exist(df = ukb_pheno,
                            required_cols)

  # expected number of rows for each fieldid should be the same - this returns a
  # numerical vector, each number is the number of columns selected for a
  # fieldid
  expected_row_numbers <- field_ids %>%
    purrr::map(get_colnames_for_fieldids,
               data_dict = data_dict) %>%
    purrr::map_dbl(length) %>%
    purrr::map_dbl(~ .x * nrow(ukb_pheno))

  # check these are numeric and all the equal
  assertthat::assert_that(is.numeric(expected_row_numbers))

  if (length(unique(expected_row_numbers)) != 1) {
    stop("Selected FieldIDs have differing numbers of associated columns")
  }

  # pivot_longer and join results into a single dataframe
  result <- field_ids %>%
    purrr::map(field_id_pivot_longer,
               ukb_pheno = ukb_pheno,
               data_dict = data_dict,
               ukb_codings = ukb_codings) %>%
    purrr::reduce(dplyr::inner_join, by = c("eid", "instance_array"))

  # check that row number matches the expected value
  if (nrow(result) != (expected_row_numbers[1])) {
    stop("Result does not contain the expected number of rows. Aborting.")
  }

  return(result)
}


#' Get death data ICD10 diagnoses
#'
#' Returns a long format dataframe with all death data ICD10 codes for each UK
#' Biobank participant.
#'
#' Reformats the data for FieldIDs 40001 and 40002 (death register
#' health-related outcomes - primary and secondary causes of death; see
#' \href{https://biobank.ndph.ox.ac.uk/showcase/label.cgi?id=100093}{category
#' 100093}).
#'
#' @inheritParams summarise_rowise
#' @inheritParams field_id_pivot_longer
#'
#' @return Dataframe
#' @export
#'
#' @family get all diagnostic codes
get_death_data_icd10_diagnoses <- function(ukb_pheno,
                                   data_dict,
                                   ukb_codings) {

  # required field_ids (see https://biobank.ndph.ox.ac.uk/showcase/label.cgi?id=100093 )
  death_data_field_ids <- c("40001", "40002")

  # initialise
  death_data_diagnoses <- vector(mode = "list", length = length(death_data_field_ids))
  names(death_data_diagnoses) <- paste0("f", death_data_field_ids)

  # get all diagnostic codes and dates (and standardise) - fieldid 40001
  death_data_diagnoses[["f40001"]] <- field_id_pivot_longer(
    field_id = "40001",
    ukb_pheno = ukb_pheno,
    data_dict = data_dict,
    ukb_codings = ukb_codings
  ) %>%
    dplyr::mutate(date = NA) %>% # date is 'NA' (cannot ascertain dates of diagnoses from death certificates)
    dplyr::filter(!is.na(f40001_value)) # remove rows with no codes

    death_data_diagnoses[["f40001"]] <- get_diagnoses_set_index_code_date_cols(get_diagnoses_df = death_data_diagnoses[["f40001"]],
                                                               index_col = "f40001",
                                                               code_col = "f40001_value",
                                                               date_col = "date")

  # get all diagnostic codes and dates (and standardise) - fieldid 40002
    death_data_diagnoses[["f40002"]] <- field_id_pivot_longer(
    field_id = "40002",
    ukb_pheno = ukb_pheno,
    data_dict = data_dict,
    ukb_codings = ukb_codings
  ) %>%
    dplyr::mutate(date = NA) %>% # date is 'NA' (cannot ascertain dates of diagnoses from death certificates)
    dplyr::filter(!is.na(f40002_value)) # remove rows with no codes

    death_data_diagnoses[["f40002"]] <- get_diagnoses_set_index_code_date_cols(get_diagnoses_df = death_data_diagnoses[["f40002"]],
                                                               index_col = "f40002",
                                                               code_col = "f40002_value",
                                                               date_col = "date")

  # combine into single df
    death_data_diagnoses <- dplyr::bind_rows(death_data_diagnoses)

  # recode to ICD10
    death_data_diagnoses <- recode_ukbcol(df = death_data_diagnoses,
                                      col_to_recode = "code",
                                      field_id = "40002",
                                      ukb_data_dict = data_dict,
                                      ukb_codings = ukb_codings,
                                      mapping_direction = "meaning_code")

  return(death_data_diagnoses)
}


#' Get hospital inpatient ICD9 diagnoses
#'
#' Returns a long format dataframe with all hospital inpatient ICD9 codes and associated dates for
#' each UK Biobank participant.
#'
#' Reformats the data for FieldIDs 41271 and 41281 (hospital inpatient diagnoses
#' and dates, see
#' \href{https://biobank.ndph.ox.ac.uk/ukb/label.cgi?id=2002}{category 2002}).
#'
#' @inheritParams summarise_rowise
#' @inheritParams field_id_pivot_longer
#'
#' @return Dataframe
#' @export
#'
#' @family get all diagnostic codes
get_hes_icd9_diagnoses <- function(ukb_pheno,
                                    data_dict,
                                    ukb_codings) {

  # required field_ids (see https://biobank.ndph.ox.ac.uk/ukb/label.cgi?id=2002 )
  hes_icd9_field_ids <- c("41271", "41281")

  # get all diagnostic codes and dates
  hes_icd9_diagnoses <- field_id_pivot_longer_multi(
    field_ids = hes_icd9_field_ids,
    ukb_pheno = ukb_pheno,
    data_dict = data_dict,
    ukb_codings = ukb_codings
  )

  # remove empty code rows
  hes_icd9_diagnoses <- hes_icd9_diagnoses %>%
    filter(!is.na(f41271_value))

  # recode to ICD10
  hes_icd9_diagnoses <- recode_ukbcol(df = hes_icd9_diagnoses,
                                       col_to_recode = "f41271_value",
                                       field_id = "41271",
                                       ukb_data_dict = data_dict,
                                       ukb_codings = ukb_codings,
                                       mapping_direction = "meaning_code")

  # standardise
  hes_icd9_diagnoses <- get_diagnoses_set_index_code_date_cols(
    get_diagnoses_df = hes_icd9_diagnoses,
    index_col = "f41271",
    code_col = "f41271_value",
    date_col = "f41281_value")

  return(hes_icd9_diagnoses)
}


#' Get hospital inpatient ICD10 diagnoses
#'
#' Returns a long format dataframe with all hospital inpatient ICD10 codes and associated dates for
#' each UK Biobank participant.
#'
#' Reformats the data for FieldIDs 41270 and 41280 (hospital inpatient diagnoses
#' and dates, see
#' \href{https://biobank.ndph.ox.ac.uk/ukb/label.cgi?id=2002}{category 2002}).
#'
#' @inheritParams summarise_rowise
#' @inheritParams field_id_pivot_longer
#'
#' @return Dataframe
#' @export
#'
#' @family get all diagnostic codes
get_hes_icd10_diagnoses <- function(ukb_pheno,
                                    data_dict,
                                    ukb_codings) {

  # required field_ids (see https://biobank.ndph.ox.ac.uk/ukb/label.cgi?id=2002)
  hes_icd10_field_ids <- c("41270", "41280")

  # get all diagnostic codes and dates
  hes_icd10_diagnoses <- field_id_pivot_longer_multi(
    field_ids = hes_icd10_field_ids,
    ukb_pheno = ukb_pheno,
    data_dict = data_dict,
    ukb_codings = ukb_codings
  )

  # remove empty code rows
  hes_icd10_diagnoses <- hes_icd10_diagnoses %>%
    filter(!is.na(f41270_value))

  # recode to ICD10
  hes_icd10_diagnoses <- recode_ukbcol(df = hes_icd10_diagnoses,
                col_to_recode = "f41270_value",
                field_id = "41270",
                ukb_data_dict = data_dict,
                ukb_codings = ukb_codings,
                mapping_direction = "meaning_code")

  # standardise
  hes_icd10_diagnoses <- get_diagnoses_set_index_code_date_cols(
    get_diagnoses_df = hes_icd10_diagnoses,
    index_col = "f41270",
    code_col = "f41270_value",
    date_col = "f41280_value")

  return(hes_icd10_diagnoses)
}


#' Get self-reported non-cancer diagnoses
#'
#' Returns a long format dataframe with all self-reported non-cancer diagnoses
#' with associated dates for each UK Biobank participant.
#'
#' Reformats the data for FieldIDs 20002 and 20008 (self-reported non-cancer
#' diagnoses and dates, see
#' \href{https://biobank.ndph.ox.ac.uk/ukb/label.cgi?id=100074}{category 100074}). Coded using
#' \href{https://biobank.ndph.ox.ac.uk/showcase/coding.cgi?id=6}{data coding 6}.
#'
#' @inheritParams summarise_rowise
#' @inheritParams field_id_pivot_longer
#'
#' @return Dataframe
#' @export
#'
#' @family get all diagnostic codes
get_self_report_non_cancer_diagnoses <- function(ukb_pheno,
                                                       data_dict,
                                                       ukb_codings) {

  # required field_ids (see https://biobank.ndph.ox.ac.uk/ukb/label.cgi?id=2002)
  self_report_non_cancer_field_ids <- c("20002", "20008")

  # get diagnostic codes and dates
  self_report_non_cancer_diagnoses <- field_id_pivot_longer_multi(
    field_ids = self_report_non_cancer_field_ids,
    ukb_pheno = ukb_pheno,
    data_dict = data_dict,
    ukb_codings = ukb_codings
  )

  # remove empty code rows
  self_report_non_cancer_diagnoses <- self_report_non_cancer_diagnoses %>%
    filter(!is.na(f20002_value))

  # recode to ukb codes
  self_report_non_cancer_diagnoses <- suppressWarnings(recode_ukbcol(df = self_report_non_cancer_diagnoses,
                                                                     col_to_recode = "f20002_value",
                                                                     field_id = "20002",
                                                                     ukb_data_dict = data_dict,
                                                                     ukb_codings = ukb_codings,
                                                                     mapping_direction = "meaning_code"))

  # standardise
  self_report_non_cancer_diagnoses <- get_diagnoses_set_index_code_date_cols(
    get_diagnoses_df = self_report_non_cancer_diagnoses,
    index_col = "f20002",
    code_col = "f20002_value",
    date_col = "f20008_value")

  # convert date_col from decimal to date type
  self_report_non_cancer_diagnoses <- self_report_non_cancer_diagnoses %>%
    dplyr::mutate(date = lubridate::as_date(lubridate::date_decimal(date)))

  return(self_report_non_cancer_diagnoses)
}


#' Get self-reported non-cancer diagnoses (ICD10)
#'
#' Returns a long format dataframe with all self-reported non-cancer diagnoses
#' mapped to 3-character ICD10 codes with associated dates for each UK Biobank participant.
#'
#' Reformats the data for FieldIDs 20002 and 20009 (self-reported non-cancer
#' diagnoses and dates, see
#' \href{https://biobank.ndph.ox.ac.uk/ukb/label.cgi?id=100074}{category 100074}).
#'
#' \strong{Note: not all self-reported medical conditions map to ICD10 codes.}
#' (See \href{https://biobank.ndph.ox.ac.uk/ukb/coding.cgi?id=609}{data coding
#' 609})
#'
#' @inheritParams summarise_rowise
#' @inheritParams field_id_pivot_longer
#'
#' @return Dataframe
#' @export
#'
#' @family get all diagnostic codes
get_self_report_non_cancer_diagnoses_icd10 <- function(ukb_pheno,
                                    data_dict,
                                    ukb_codings) {

  self_report_non_cancer_diagnoses_icd10 <-
    get_self_report_non_cancer_diagnoses(ukb_pheno = ukb_pheno,
                                         data_dict = data_dict,
                                         ukb_codings = ukb_codings)

  # ...now recode to ICD10
  mapping_df <- ukb_codings %>%
    dplyr::filter(Coding == 609 & Value != -1) %>%
    dplyr::select(old_vals = Value,
                  new_vals = Meaning)


  self_report_non_cancer_diagnoses_icd10 <- suppressWarnings(recode_column(df = self_report_non_cancer_diagnoses_icd10,
                                                                     col_to_recode = "code",
                                                                     mapping_df = mapping_df))

  # remove rows with no code (not all self-reported conditions map to ICD10)
  self_report_non_cancer_diagnoses_icd10 <- self_report_non_cancer_diagnoses_icd10 %>%
    dplyr::filter(!is.na(code))

  # relabel 'source' col to indicate these are icd10 codes
  self_report_non_cancer_diagnoses_icd10 <- self_report_non_cancer_diagnoses_icd10 %>%
    dplyr::mutate(source = paste0(source, "_icd10"))

  return(self_report_non_cancer_diagnoses_icd10)
}


#' Get self-reported cancer diagnoses
#'
#' Returns a long format dataframe with all self-reported cancer diagnoses
#' with associated dates for each UK Biobank participant.
#'
#' Reformats the data for FieldIDs 20001 and 20006 (self-reported cancer
#' diagnoses and dates, see
#' \href{https://biobank.ndph.ox.ac.uk/ukb/label.cgi?id=100074}{category 100074}). Coded using
#' \href{https://biobank.ndph.ox.ac.uk/showcase/coding.cgi?id=3}{data coding 3}.
#'
#' @inheritParams summarise_rowise
#' @inheritParams field_id_pivot_longer
#'
#' @return Dataframe
#' @export
#'
#' @family get all diagnostic codes
get_self_report_cancer_diagnoses <- function(ukb_pheno,
                                                 data_dict,
                                                 ukb_codings) {

  # required field_ids (see https://biobank.ndph.ox.ac.uk/ukb/label.cgi?id=2002)
  self_report_cancer_field_ids <- c("20001", "20006")

  # get diagnostic codes and dates
  self_report_cancer_diagnoses <- field_id_pivot_longer_multi(
    field_ids = self_report_cancer_field_ids,
    ukb_pheno = ukb_pheno,
    data_dict = data_dict,
    ukb_codings = ukb_codings
  )

  # remove empty code rows
  self_report_cancer_diagnoses <- self_report_cancer_diagnoses %>%
    filter(!is.na(f20001_value))

  # recode to ukb codes
  self_report_cancer_diagnoses <- suppressWarnings(recode_ukbcol(df = self_report_cancer_diagnoses,
                                                                     col_to_recode = "f20001_value",
                                                                     field_id = "20001",
                                                                     ukb_data_dict = data_dict,
                                                                     ukb_codings = ukb_codings,
                                                                     mapping_direction = "meaning_code"))

  # standardise
  self_report_cancer_diagnoses <- get_diagnoses_set_index_code_date_cols(
    get_diagnoses_df = self_report_cancer_diagnoses,
    index_col = "f20001",
    code_col = "f20001_value",
    date_col = "f20006_value")

  # convert date_col from decimal to date type
  self_report_cancer_diagnoses <- self_report_cancer_diagnoses %>%
    dplyr::mutate(date = lubridate::as_date(lubridate::date_decimal(date)))

  return(self_report_cancer_diagnoses)
}


#' Get cancer register ICD9 diagnoses
#'
#' Returns a long format dataframe with all ICD9 cancer register diagnoses
#' with associated dates for each UK Biobank participant.
#'
#' Reformats the data for FieldIDs 40013 and 40005 (cancer register diagnoses and dates, see
#' \href{https://biobank.ndph.ox.ac.uk/showcase/label.cgi?id=100092}{category 100092}).
#'
#' @inheritParams summarise_rowise
#' @inheritParams field_id_pivot_longer
#'
#' @return Dataframe
#' @export
#'
#' @family get all diagnostic codes
get_cancer_register_icd9_diagnoses <- function(ukb_pheno,
                                             data_dict,
                                             ukb_codings) {

  # required field_ids (see https://biobank.ndph.ox.ac.uk/ukb/label.cgi?id=2002)
  cancer_register_icd9_field_ids <- c("40013", "40005")

  # **TEMPFIX** - for fieldid 40013 (ICD9), there are only 14 instances, where as
  # fieldid 40006 (ICD10) and 40005 (date of cancer diagnosis) have 16
  # instances. field_id_pivot_longer_multi() raises an error if the number of
  # instances are not equal

  # Therefore, remove the 'extra' instance columns for 40005 before proceeding
  cols_to_remove <- data_dict %>%
    dplyr::filter(FieldID == "40005") %>%
    dplyr::filter(instance %in% c("14", "15")) %>%
    .$descriptive_colnames

  if (rlang::is_empty(cols_to_remove)) {
    stop("Required fields are not present in data_dict")
  }

  ukb_pheno <- ukb_pheno %>%
    dplyr::select(-tidyselect::all_of(cols_to_remove))

  data_dict <- data_dict %>%
    dplyr::filter(!(descriptive_colnames %in% cols_to_remove))

  # get diagnostic codes and dates
  cancer_register_icd9_diagnoses <- field_id_pivot_longer_multi(
    field_ids = cancer_register_icd9_field_ids,
    ukb_pheno = ukb_pheno,
    data_dict = data_dict,
    ukb_codings = ukb_codings
  )

  # remove empty code rows
  cancer_register_icd9_diagnoses <- cancer_register_icd9_diagnoses %>%
    filter(!is.na(f40013_value))

  # recode to ICD9
  cancer_register_icd9_diagnoses <- recode_ukbcol(df = cancer_register_icd9_diagnoses,
                                      col_to_recode = "f40013_value",
                                      field_id = "40013",
                                      ukb_data_dict = data_dict,
                                      ukb_codings = ukb_codings,
                                      mapping_direction = "meaning_code")

  # standardise
  cancer_register_icd9_diagnoses <- get_diagnoses_set_index_code_date_cols(
    get_diagnoses_df = cancer_register_icd9_diagnoses,
    index_col = "f40013",
    code_col = "f40013_value",
    date_col = "f40005_value")

  return(cancer_register_icd9_diagnoses)
}


#' Get cancer register ICD10 diagnoses
#'
#' Returns a long format dataframe with all ICD10 cancer register diagnoses
#' with associated dates for each UK Biobank participant.
#'
#' Reformats the data for FieldIDs 40006 and 40005 (cancer register diagnoses and dates, see
#' \href{https://biobank.ndph.ox.ac.uk/showcase/label.cgi?id=100092}{category 100092}).
#'
#' @inheritParams summarise_rowise
#' @inheritParams field_id_pivot_longer
#'
#' @return Dataframe
#' @export
#'
#' @family get all diagnostic codes
get_cancer_register_icd10_diagnoses <- function(ukb_pheno,
                                               data_dict,
                                               ukb_codings) {

  # required field_ids (see https://biobank.ndph.ox.ac.uk/ukb/label.cgi?id=2002)
  cancer_register_icd10_field_ids <- c("40006", "40005")

  # get diagnostic codes and dates
  cancer_register_icd10_diagnoses <- field_id_pivot_longer_multi(
    field_ids = cancer_register_icd10_field_ids,
    ukb_pheno = ukb_pheno,
    data_dict = data_dict,
    ukb_codings = ukb_codings
  )

  # remove empty code rows
  cancer_register_icd10_diagnoses <- cancer_register_icd10_diagnoses %>%
    filter(!is.na(f40006_value))

  # recode to ICD9
  cancer_register_icd10_diagnoses <- recode_ukbcol(df = cancer_register_icd10_diagnoses,
                                                  col_to_recode = "f40006_value",
                                                  field_id = "40006",
                                                  ukb_data_dict = data_dict,
                                                  ukb_codings = ukb_codings,
                                                  mapping_direction = "meaning_code")

  # standardise
  cancer_register_icd10_diagnoses <- get_diagnoses_set_index_code_date_cols(
    get_diagnoses_df = cancer_register_icd10_diagnoses,
    index_col = "f40006",
    code_col = "f40006_value",
    date_col = "f40005_value")

  return(cancer_register_icd10_diagnoses)
}


#' Get all diagnostic codes from multiple data sources
#'
#' Extract diagnostic codes from multiple sources
#'
#' Loops through a list of functions (`function_list`) from the 'get all
#' diagnostic codes' family and combines the results into a single dataframe.
#'
#' @param function_list A list of `get_XXXX_diagnoses` functions.
#' @inheritParams get_self_report_non_cancer_diagnoses_icd10
#' @param drop_source_col Remove `source_col` column, which records which column
#'   in the main dataset the value in `code` column came from. Default is
#'   `TRUE`.
#'
#' @return Dataframe
#' @export
#' @family get all diagnostic codes
get_all_diagnostic_codes_multi <- function(function_list = list(get_self_report_non_cancer_diagnoses_icd10,
                                                                get_hes_icd9_diagnoses,
                                                                get_hes_icd10_diagnoses,
                                                                get_death_data_icd10_diagnoses,
                                                                get_cancer_register_icd9_diagnoses,
                                                                get_cancer_register_icd10_diagnoses),
                                           ukb_pheno,
                                           data_dict,
                                           ukb_codings,
                                           drop_source_col = TRUE) {
  # initialise empty results list
  result <- vector(mode = "list",
                   length = length(function_list))

  # initialist progress bar
  pb <- progress::progress_bar$new(format = "[:bar] :current/:total (:percent)",
                                                          total = length(function_list))
  pb$tick(0)

  # loop through 'get all diagnostic code' functions - populate results list
  for (func in seq_along(function_list)){
    # progress bar
    pb$tick(1)

    # get diagnoses
    result[[func]] <- function_list[[func]](ukb_pheno = ukb_pheno,
                                                 data_dict = data_dict,
                                                 ukb_codings = ukb_codings)
  }

  # combine results into single df
  result <- dplyr::bind_rows(result)

  # remove source_col if requested (default is to remove)
  if (drop_source_col == TRUE) {
    result <- result %>%
      dplyr::select(-source_col)
  }

  # return result
  return(result)
}


# PRIVATE FUNCTIONS -------------------------------------------------------


#' Standardise a long format diagnoses dataframe
#'
#' Helper function
#'
#' Selects essential columns: eid, field_id, code and date recorded.
#'
#' @param get_diagnoses_df a dataframe created by a 'get_X_diagnoses' function
#' @param index_col Column indicating diagnosis source (e.g. HES, self-report)
#' @param code_col Column of codes
#' @param date_col Column of dates when code was recorded
#' @family get all diagnostic codes
get_diagnoses_set_index_code_date_cols <- function(get_diagnoses_df,
                                                   index_col,
                                                   code_col,
                                                   date_col) {

  # create 'source' col indicating which FieldID the data (code) comes from
  get_diagnoses_df$source <- index_col

  # select required columns and rename
  get_diagnoses_df <- get_diagnoses_df %>%
    select(eid,
           source,
           code = .data[[code_col]],
           date = .data[[date_col]],
           source_col = .data[[index_col]])

  return(get_diagnoses_df)
}


#' Get first record for a set of diagnostic codes (generic)
#'
#' Generic helper function. For a set of diagnostic codes, extract eids with at
#' least one of these and the associated earliest recorded date.
#'
#' @param df A dataframe generated by one of the 'get all diagnostic codes'
#'   functions
#' @param codes Character vector of diagnostic codes
#'
#' @return A dataframe nested by eid, with columns for the earliest date one of
#'   the specified codes was recorded
#'
#' @family get specific diagnostic codes, first recorded
get_first_diagnostic_code_record_basis <- function(df,
                                                   codes) {
  # check there are no NA values for 'code' column
  assertthat::assert_that(sum(is.na(df$code)) == 0,
                          msg = "Error! Some rows have no diagnostic code (there should be no missing values)")

  # check that date column is date type (not character)
  assertthat::is.date(df$date)

  # mapping function to extract earliest diagnostic code data for each eid -
  # returns a single character.
  get_earliest_record_mapper <- function(df) {
    # get row index for earliest date
    earliest_date <- which.min(df$date)

    # if there are no dates, return the first row of codes
    if (rlang::is_empty(earliest_date)) {
      return(df[1, ] %>%
               dplyr::select(-date) %>%
               tidyr::unite("result", sep = "_SEP_", remove = TRUE) %>%
               .$result)
    }

    # otherwise, return first date
    df[earliest_date,] %>%
      tidyr::unite("result", sep = "_SEP_", remove = TRUE) %>%
      .$result
  }

  # filter for selected codes, nest by eid and extract earliest date + code (or
  # just a code if no dates available)
  df %>%
    dplyr::filter(code %in% codes) %>%
    dplyr::group_by(eid) %>%
    tidyr::nest() %>%
    dplyr::mutate(result = purrr::map_chr(data, get_earliest_record_mapper)) %>%
    tidyr::separate(result,
             into = c("source", "code", "date"),
             sep = "_SEP_") %>%
    suppressWarnings() # separate() raises if there are rows with no dates - suppress these
}
