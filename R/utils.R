
# EXPORTED FUNCTIONS ------------------------------------------------------

#' Quickly summarise a dataframe
#'
#' A tidyverse-friendly summary function that summarises a dataframe by column type
#'
#' Works with \code{dplyr::group_by()} and the pipe. See the
#' \code{\link[skimr]{skim}} documentation for more details. Adapts the
#' \code{skimr::skim()} function to include proportion counts for factor
#' variables
#'
#' @inheritParams skimr::skim
#'
#' @export
my_skim <- skimr::skim_with(
  # factor - a long anonymous function that converts a prop table to a single string
  factor = skimr::sfl(pct = function(x) {
    # make a prop table in %
    pct_table <- prop.table(table(x)) * 100

    # round % to 1dp
    pct_table <- round(pct_table, 1)

    # zip the table names and values together
    combined_vector <- vector(mode = 'character', length = 0L)
    for (i in 1:length(pct_table)) {
      combined_vector <- c(combined_vector, paste0(names(pct_table)[i], ":"))
      combined_vector <- c(combined_vector, paste0(as.character(pct_table)[i], "%,"))
    }

    # see result
    combined_vector

    # glue character vector into single string
    combined_vector <- stringr::str_c(combined_vector, collapse = " ")

    # return result
    return(combined_vector)
  }),

  # logical - returns proportion = TRUE
  logical = skimr::sfl(pct_TRUE = function(x) {sum(x == TRUE, na.rm=TRUE) / length(x) * 100})
)

#' Get descriptive colnames associated with one or more FieldIDs
#'
#' Returns all descriptive column names matching one or more FieldIDs.
#'
#' Use this in functions which manipulate a UKB phenotype dataset processed by
#' \code{\link{read_pheno}}. Should the convention for descriptive column names
#' change then so will these functions, however changes would only need to be
#' updated at the start of each function.
#'
#' @param field_ids Character. A UK Biobank Field ID
#' @param data_dict a data dictionary generated by
#'   \code{\link{pheno_data_dict}}
#'
#' @export
#'
#' @return A character vector of descriptive colnames
#'
#' @family data dictionary helper functions
get_colnames_for_fieldids <- function(field_ids,
                                     data_dict,
                                     scalar_output = FALSE) {

  col_names <- filter_data_dict(data_dict = data_dict,
                   filter_col = "FieldID",
                   filter_value = field_ids,
                   return_col = "descriptive_colnames")

  if (scalar_output == TRUE) {
    assertthat::is.scalar(col_names)
  }

  return(col_names)
}


#' Get UKB codings for one or more FieldIDs
#'
#' General helper function - filters
#' \href{https://biobank.ctsu.ox.ac.uk/crystal/exinfo.cgi?src=accessing_data_guide}{`ubk_codings`}
#' for the codings associated with one or more FieldIDs.
#'
#' @param field_ids Character. One or more UKB FieldIDs
#' @param ukb_data_dict UKB data dictionary
#' @param ukb_codings UKB Codings dictionary
#'
#' @return Dataframe.
#'
#' @export
extract_codings_for_fieldids <- function(field_ids,
                                        ukb_data_dict,
                                        ukb_codings) {
  ukb_codings %>%
    filter(Coding == (
      ukb_data_dict %>%
        filter(FieldID %in% field_ids) %>%
        .$Coding %>%
        head(n = 1)
    ))
}

#' Download UKB data dictionary
#'
#' Downloads the UK Biobank data dictionary from the
#' \href{https://biobank.ctsu.ox.ac.uk/crystal/exinfo.cgi?src=accessing_data_guide}{UK
#' Biobank website} and reads into R with all columns as character type.
#'
#' @export
get_ukb_data_dict <- function() {
  fread_tsv_as_character("https://biobank.ctsu.ox.ac.uk/~bbdatan/Data_Dictionary_Showcase.tsv")
}

#' Download UKB codings file
#'
#' Downloads the UK Biobank codings list from the
#' \href{https://biobank.ctsu.ox.ac.uk/crystal/exinfo.cgi?src=accessing_data_guide}{UK
#' Biobank website} and reads into R with all columns as character type.
#'
#' @export
get_ukb_codings <- function() {
  fread_tsv_as_character("https://biobank.ctsu.ox.ac.uk/~bbdatan/Codings.tsv")
}

# PRIVATE FUNCTIONS -------------------------------------------------------

#' Generic helper function values from a data dictionary
#'
#' Filters a UK Biobank data dictionary on one column and returns the values
#' from another column (e.g. filter data dictionary for a FieldID, and return
#' the corresponding descriptive column name(s))
#'
#' General helper function. Raises an error if produces and empty vector
#'
#' @param data_dict a data dictionary generated by \code{\link{pheno_data_dict}}
#' @param filter_col Character. The column in `data_dict` to filter on.
#' @param filter_value Character (single or multiple). Filter for values in
#'   `filter_col` that match one of these.
#' @param return_col Character. The column in `data_dict` to return after
#'   filtering.
#'
#' @return A vector.
#'
#' @family data dictionary helper functions
filter_data_dict <- function(data_dict,
                             filter_col,
                             filter_value,
                             return_col) {
  data_dict <- data_dict %>%
    filter(.data[[filter_col]] %in% filter_value) %>%
    .[[return_col]]

  # Error if produces an empty vector
  if (rlang::is_empty(data_dict)) {
    stop("Error! Required values not present in data dictionary: ", filter_value)
  } else {
    return(data_dict)
  }
}



#' Helper function for \code{\link{recode_ukbcol}}
#'
#' Generates a `mapping_df` for \code{\link{recode_ukbcol}}
#'
#' @inheritParams recode_ukbcol
#'
#' @family recode UKB values
recode_column_coding_meaning_value_mapping_df <- function(field_id,
                                                           ukb_data_dict,
                                                           ukb_codings,
                                                           mapping_direction = "meaning_code") {
  # check user supplied a valid `mapping_direction` value - error if not
  if (!(mapping_direction %in% c("meaning_code", "code_meaning"))) {
    stop("Argument `mapping_direction` must be either 'meaning_code' or 'code_meaning'")
  }

  # get coding/meaning for the specified field_id
  ukb_codings <- extract_codings_for_fieldids(
    field_id = field_id,
    ukb_data_dict = ukb_data_dict,
    ukb_codings = ukb_codings
  )

  # label according to mapping direction
  if (mapping_direction == "meaning_code") {
    ukb_codings <- ukb_codings %>%
      rename(old_vals = Meaning,
             new_vals = Value) %>%
      select(-Coding)
  } else if (mapping_direction == "code_meaning") {
    ukb_codings <- ukb_codings %>%
      rename(old_vals = Value,
             new_vals = Meaning) %>%
      select(-Coding)
  }

  return(ukb_codings)
}


#' Recode values in a UK Biobank dataframe for a single column
#'
#' Recodes values in a specified column from descriptive label to UK Biobank
#' coding (default) or vice versa
#'
#' @section Under the hood:
#'
#' The UK Biobank codings for a given FieldID (`field_id`) are extracted into
#'   a `mapping_df`, which is formatted for use with
#'   \code{\link{recode_column}}. This then recodes the specified column
#'   (`col_to_recode`) in `df` from either meaning to raw UK Biobank codings
#'   (default) or vice versa.
#'
#' @seealso columns "Value" and "Meaning" in the
#'   \href{https://biobank.ctsu.ox.ac.uk/crystal/exinfo.cgi?src=accessing_data_guide}{UKB
#'    codings dictionary}
#'
#' @param df A dataframe
#' @param col_to_recode Name of column in `df` to be recoded
#' @param field_id Character. A UK Biobank FieldID
#' @inheritParams read_pheno
#' @param mapping_direction Character. Either "meaning_code" (default) or
#'   "code_meaning"
#' @family recode UKB values
recode_ukbcol <- function(df,
                          col_to_recode,
                          field_id,
                          ukb_data_dict,
                          ukb_codings,
                          mapping_direction = "meaning_code") {
  # make mapping_df with old and new col values
  mapping_df <- recode_column_coding_meaning_value_mapping_df(field_id = field_id,
                                                               ukb_data_dict = ukb_data_dict,
                                                               ukb_codings = ukb_codings,
                                                               mapping_direction = "meaning_code")

  # remove coding values with multiple associated meanings for categorical fields
  # (see also misc_ukb_codings.Rmd)
  if (field_id %in% c("20001",
                      "20002",
                      "20004",
                      "40013",
                      "41203",
                      "41205",
                      "41271")) {
    mapping_df <- mapping_df %>%
      dplyr::filter(!(old_vals %in% c("-1", "Chapter V")) &
                      !(new_vals %in% c("-1", "Chapter V")))
  }

  # for fieldid 20002, 'myasthenia gravis' has 2  associated codes - remove one of these if
  # mapping from meaning back to codes. Also see:
  # https://biobank.ndph.ox.ac.uk/ukb/coding.cgi?id=6
  if (field_id == "20002" & mapping_direction == "meaning_code") {
    mapping_df <- mapping_df %>%
      dplyr::filter(new_vals != "1260")
  }

  # relabel
  df <- recode_column(df = df,
                       col_to_recode = col_to_recode,
                       mapping_df = mapping_df)

  return(df)
}


#' Recode values in a dataframe column
#'
#' Returns the input dataframe with recoded values in the specified
#' `col_to_recode`
#'
#' Uses a `mapping_df` to recode the values for a selected column
#' (`col_to_recode`) in a dataframe (`df`). The `mapping_df` should only contain
#' 2 columns named "old_vals" (containing values in `df[[col_to_recode]]` to be
#' recoded) and "new_vals" (replacement values). There should also be no duplicated values in either column.
#'
#' A warning is generated if `mapping_df$old_vals` does not contain all values
#' in `df`, or if the return value has more rows than the original `df` (i.e. a
#' mutating join has been performed)
#'
#' @section Under the hood:
#'
#'   Uses \code{\link[dplyr]{left_join}} to merge `df` and `mapping_df`,
#'   retaining the "new_vals" in `mapping_df`.
#'
#' @param df a dataframe
#' @param col_to_recode Character - name of column in `df` to be recoded
#' @param mapping_df a dataframe with 2 columns named "old_vals" and "new_vals"
#'
#' @family recode UKB values
recode_column <- function(df, col_to_recode, mapping_df) {

  # check nrow for input df
  original_nrow <- nrow(df)

  # check mapping_df is valid
  # - must have 2 columns named "old_vals" and "new_vals".
  # - All values in both columns are unique
  # Error if any checks fail
  if (!(all(names(mapping_df) == c("old_vals", "new_vals")) |
        all(names(mapping_df) == c("new_vals", "old_vals")))) {
    stop("Invalid `mapping_df`: must be a dataframe with 2 columns named 'old_vals' and 'new_vals'")
  }

 if(
   length(unique(mapping_df$old_vals)) != nrow(mapping_df)
    # length(unique(mapping_df$new_vals)) != nrow(mapping_df)
   ) {
   stop("`mapping_df` must contain only unique values in 'old_vals' column")
 }

  # Warning if "old_vals" does not contain all values in df
  if (length(setdiff(unique(na.omit(df[[col_to_recode]])), mapping_df$old_vals)) > 0) {
    warning("WARNING! `mapping_df` does not contain all unique values in `df[[col_to_Recode]]`.
            Some values will not have been recoded - is this intentional?")
  }

  # rename col_to_recode before joining with mapper
  names(df)[which(names(df) == col_to_recode)] <- "old_vals"

  # join with mapper and drop old column - TODO replace this with
  # a dictionary-like function (would be safer and faster?)

  # TO DELETE- looping is very slow
  # pb <- progress::progress_bar$new(format = "[:bar] :current/:total (:percent)",
  #                        total = nrow(df))
  # recode_helper <- function(x,
  #                           mapping_df) {
  #   # return the corresponding 'new_val' for an 'old_val'
  #   pb$tick()
  #   result <- mapping_df %>%
  #     dplyr::filter(old_vals == x) %>%
  #     .$new_vals
  #
  #   if (rlang::is_empty(result)) {
  #     return(NA)
  #   } else {
  #     return(result)
  #   }
  # }
  #
  # message("\nrecoding...\n")
  # df <- df %>%
  #   dplyr::mutate(old_vals = map_chr(old_vals,
  #                                    recode_helper,
  #                                    mapping_df))

  df <- df %>%
    dplyr::left_join(mapping_df,
              by = "old_vals") %>%
    dplyr::mutate(old_vals = new_vals) %>%
    dplyr::select(-new_vals)

  # rename to original colname
  names(df)[which(names(df) == "old_vals")] <- col_to_recode

  # # warning message if returns a result with more rows than the original input
  if (nrow(df) > original_nrow) {
    warning("WARNING! New dataframe has more rows than the original input. Was this intentional?")
    }

  return(df)
}



#' Check required columns are present
#'
#' Combines supplied character vectors into a single vector, then checks whether
#' these are all present in `names(df)`. Raises an error if not.
#'
#' @param df Dataframe
#' @param ... Character vector(s)
check_required_cols_exist <- function(df,
                                      ...) {
  # combine input colnames into single character vector
  required_cols <- list(...) %>% purrr::reduce(c)

  # error if not all required cols present in df
  if (!all(required_cols %in% names(df))) {
    # invisible(required_cols) # TODO: is there a way to return a character
    # vector of required columns?
    # make print-friendly version of required cols
    # paste(required_cols, collapse = "\n\n")

    stop("Required columns not present in data")
  }
}


#' Read a tsv file with all columns as type character
#'
#' Wrapper around \code{\link[data.table]{fread}}
#'
fread_tsv_as_character <- purrr::partial(data.table::fread,
                                         colClasses = c('character'),
                                         sep = "\t",
                                         quote = " ",
                                         na.strings = c("", "NA"))

#' Display time taken message
#'
#' Helper function for displaying time taken messages within other functions. Use
#' \code{\link[base]{proc.time}} at start of function and supply this as the
#' `start_time` parameter to this function.
#'
#' @param start_time The start time.
#'
#' @return A message stating time taken since start time
time_taken_message <- function(start_time) {
  # get time taken
  time_taken <- proc.time() - start_time

  # display message
  message("Time taken: ",
        (time_taken[3] %/% 60),
        " minutes, ",
        (round(time_taken[3] %% 60)),
        " seconds.")
}
